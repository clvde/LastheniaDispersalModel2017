curr_pop_eg <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop_eg
library(statmod)
meta_cols <- 3 # the number of metadata columns in the matrix (generation number, individual number, location)
neut_locus_1 <- env_locus_last + 1
#Packages#
library(statmod)#
#
# Constants#
meta_cols <- 3 # the number of metadata columns in the matrix (generation number, individual number, location)#
meta_col_names <- c('generation','individual_ID','location')#
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 # (50 seeds per inflorescence, 1 inflorescence MAX)#
Rmax_bad <- 0#
nstar <- 1000#
p_mut <- 0.00001 # probability of mutation at every allele#
sigma_mut <- 0.001 # standard deviation of the mutation kernel#
nbhd_width <- 1 # can set this equal to 1 without loss of generality as the whole environment can be large or small relative to this. #
env_length <- 10 # this should be varied so the gene flow (i.e. the neighbourhood size to environment size varies) as this may have consequences for dipsersal evo#
t_max <- 10#
init_loc_mean <- 0#
nstar <- 1000#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 3#
#
# Derived Constants#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
# derived inputs/function tests#
#
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
df_shell#
curr_pop_eg <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop_eg
mom_eg <- curr_pop_eg[1,]
mom_eg
curr_pop_eg <- curr_pop_eg[-1,]
curr_pop_eg
zwi <- zw(mom_eg, env_locus_1, env_locus_last)
zwi
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
Rmax
Ri <- R(Rmax, k, zwi)
Ri
nix <- localdensity(mom_eg, curr_pop_eg)
nix
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
df_shell#
curr_pop_eg <- make_pop(0, nstar+1000, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop_eg#
mom_eg <- curr_pop_eg[1,]#
mom_eg#
curr_pop_eg <- curr_pop_eg[-1,]#
curr_pop_eg
zwi <- zw(mom_eg, env_locus_1, env_locus_last)
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
Rmax
Ri <- R(Rmax, k, zwi)
Ri
nix <- localdensity(mom_eg, curr_pop_eg)
nix
Eo <- expoffspring(zw, nix, nstar, Rmax_good, k)
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)
#Packages#
library(statmod)#
#
# Constants#
meta_cols <- 3 # the number of metadata columns in the matrix (generation number, individual number, location)#
meta_col_names <- c('generation','individual_ID','location')#
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 # (50 seeds per inflorescence, 1 inflorescence MAX)#
Rmax_bad <- 0#
nstar <- 1000#
p_mut <- 0.00001 # probability of mutation at every allele#
sigma_mut <- 0.001 # standard deviation of the mutation kernel#
nbhd_width <- 1 # can set this equal to 1 without loss of generality as the whole environment can be large or small relative to this. #
env_length <- 10 # this should be varied so the gene flow (i.e. the neighbourhood size to environment size varies) as this may have consequences for dipsersal evo#
t_max <- 10#
init_loc_mean <- 0#
nstar <- 1000#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 3#
#
# Derived Constants#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
# derived inputs/function tests#
#
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
df_shell#
curr_pop_eg <- make_pop(0, nstar+1000, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop_eg#
mom_eg <- curr_pop_eg[1,]#
mom_eg#
curr_pop_eg <- curr_pop_eg[-1,]#
curr_pop_eg
zwi <- zw(mom_eg, env_locus_1, env_locus_last)
zwi
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
Rmax#
Ri <- R(Rmax, k, zwi)#
Ri#
nix <- localdensity(mom_eg, curr_pop_eg)#
nix
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)
Eo
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
dadIDs <- matefinder1D(nbabies, mom_eg, curr_pop_eg, nbhd_width)
dadIDs
dadIDs[,4] > 0
dadIDs_conv <- convert_dads_list(dadIDs)
convert_dads_list <- function(dadIDs){#
#
	dad_indices <- which(dadIDs$offspring_counts>0, arr.ind=TRUE)[,1]#
	IDs <- as.vector(dadIDs$individual_ID)[dad_indices]#
	offspring <- as.vector(dadIDs$offspring_counts)[dad_indices]#
	dads_by_offnum <- c()#
	for (i in 1:length(IDs)){#
		if (offspring > 0){#
			tempvec <- matrix(data = IDs[i], nrow = 1, ncol = offspring[i])#
			dads_by_offnum <- c(dads_by_offnum, tempvec)#
		}#
	}#
	return(dads_by_offnum)#
}
dadIDs_conv <- convert_dads_list(dadIDs)
convert_dads_list <- function(dadIDs){#
#
	dad_indices <- which(dadIDs$offspring_counts>0, arr.ind=TRUE)[,1]#
	IDs <- as.vector(dadIDs$individual_ID)[dad_indices]#
	offspring <- as.vector(dadIDs$offspring_counts)[dad_indices]#
	dads_by_offnum <- c()#
	for (i in 1:length(IDs)){#
		if (length(offspring) > 0){#
			tempvec <- matrix(data = IDs[i], nrow = 1, ncol = offspring[i])#
			dads_by_offnum <- c(dads_by_offnum, tempvec)#
		}#
	}#
	return(dads_by_offnum)#
}
dadIDs_conv <- convert_dads_list(dadIDs)
dadIDs_conv
convert_dads_list <- function(dadIDs){#
#
	dad_indices <- which(dadIDs$offspring_counts>0, arr.ind=TRUE)[,1]#
	IDs <- as.vector(dadIDs$individual_ID)[dad_indices]#
	offspring <- as.vector(dadIDs$offspring_counts)[dad_indices]#
	dads_by_offnum <- vector()#
	for (i in 1:length(IDs)){#
		if (length(offspring) > 0){#
			tempvec <- matrix(data = IDs[i], nrow = 1, ncol = offspring[i])#
			dads_by_offnum <- c(dads_by_offnum, tempvec)#
		}#
	}#
	return(dads_by_offnum)#
}
dadIDs_conv <- convert_dads_list(dadIDs)
dadIDs_conv
#Packages#
library(statmod)#
#
# Constants#
meta_cols <- 3 # the number of metadata columns in the matrix (generation number, individual number, location)#
meta_col_names <- c('generation','individual_ID','location')#
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 # (50 seeds per inflorescence, 1 inflorescence MAX)#
Rmax_bad <- 0#
nstar <- 10000#
p_mut <- 0.00001 # probability of mutation at every allele#
sigma_mut <- 0.001 # standard deviation of the mutation kernel#
nbhd_width <- 1 # can set this equal to 1 without loss of generality as the whole environment can be large or small relative to this. #
env_length <- 10 # this should be varied so the gene flow (i.e. the neighbourhood size to environment size varies) as this may have consequences for dipsersal evo#
t_max <- 10#
init_loc_mean <- 0#
nstar <- 1000#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 3#
#
# Derived Constants#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
# derived inputs/function tests#
#
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
df_shell#
curr_pop_eg <- make_pop(0, nstar+1000, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop_eg#
mom_eg <- curr_pop_eg[1,]#
mom_eg#
curr_pop_eg <- curr_pop_eg[-1,]#
curr_pop_eg#
#
zwi <- zw(mom_eg, env_locus_1, env_locus_last)#
zwi#
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)#
Rmax#
Ri <- R(Rmax, k, zwi)#
Ri#
nix <- localdensity(mom_eg, curr_pop_eg)#
nix#
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)#
Eo#
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)#
nbabies#
dadIDs <- matefinder1D(nbabies, mom_eg, curr_pop_eg, nbhd_width)#
dadIDs#
dadIDs_conv <- convert_dads_list(dadIDs)#
dadIDs_conv#
zdai <- zda(mom_eg, disp_a_locus_1, disp_a_locus_last)#
zdbi <- zdb(mom_eg,disp_b_locus_1, disp_b_locus_last)#
baby <- make_offspring(mom_eg, curr_pop_eg[4], 0, 1)#
d1D <- disperse1D(mom_eg$location, zdai, zdbi)#
d1D#
environment(dix, Rmax_good, Rmax_bad, t, env_length)
dadIDs_conv <- convert_dads_list(dadIDs)
dadIDs_conv
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
df_shell
curr_pop_eg <- make_pop(0, nstar+1000, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop_eg
mom_eg <- curr_pop_eg[1,]
mom_eg
curr_pop_eg <- curr_pop_eg[-1,]
curr_pop_eg
zwi <- zw(mom_eg, env_locus_1, env_locus_last)
zwi
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
Rmax
Ri <- R(Rmax, k, zwi)
Ri
nix <- localdensity(mom_eg, curr_pop_eg)
nix
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)
Eo
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
#Packages#
library(statmod)#
#
# Constants#
meta_cols <- 3 # the number of metadata columns in the matrix (generation number, individual number, location)#
meta_col_names <- c('generation','individual_ID','location')#
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 # (50 seeds per inflorescence, 1 inflorescence MAX)#
Rmax_bad <- 0#
nstar <- 10000#
p_mut <- 0.00001 # probability of mutation at every allele#
sigma_mut <- 0.001 # standard deviation of the mutation kernel#
nbhd_width <- 1 # can set this equal to 1 without loss of generality as the whole environment can be large or small relative to this. #
env_length <- 10 # this should be varied so the gene flow (i.e. the neighbourhood size to environment size varies) as this may have consequences for dipsersal evo#
t_max <- 10#
init_loc_mean <- 0#
nstar <- 1000#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 0#
#
# Derived Constants#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
# derived inputs/function tests#
#
df_shell <- make_popn_dataframe(t, 3, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
df_shell#
curr_pop_eg <- make_pop(0, nstar+1000, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop_eg#
mom_eg <- curr_pop_eg[1,]#
mom_eg#
curr_pop_eg <- curr_pop_eg[-1,]#
curr_pop_eg#
#
zwi <- zw(mom_eg, env_locus_1, env_locus_last)#
zwi#
Rmax <- environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)#
Rmax#
Ri <- R(Rmax, k, zwi)#
Ri#
nix <- localdensity(mom_eg, curr_pop_eg)#
nix#
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)#
Eo
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
dadIDs <- matefinder1D(nbabies, mom_eg, curr_pop_eg, nbhd_width)
dadIDs
dadIDs_conv <- convert_dads_list(dadIDs)
dadIDs_conv
zdai <- zda(mom_eg, disp_a_locus_1, disp_a_locus_last)
zdbi <- zdb(mom_eg,disp_b_locus_1, disp_b_locus_last)
baby <- make_offspring(mom_eg, curr_pop_eg[4], 0, 1)
zdai
zdbi
baby <- make_offspring(mom_eg, curr_pop_eg[4], 0, 1)
baby
d1D <- disperse1D(mom_eg$location, zdai, zdbi)
d1D
environment(dix, Rmax_good, Rmax_bad, t, env_length)
environment(dix, Rmax_good, Rmax_bad, 0, env_length)
environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
Eo <- expoffspring(zwi, nix, nstar, Rmax_good, k)
nbabies <- reproduce(mom_eg, nstar, Rmax, k, curr_pop_eg)
nbabies
dadIDs <- matefinder1D(nbabies, mom_eg, curr_pop_eg, nbhd_width)
dadIDs_conv <- convert_dads_list(dadIDs)
dadIDs_conv
dadIDs_conv[1]
dadIDs_conv
environment(mom_eg$location, Rmax_good, Rmax_bad, 0, env_length)
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t,meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-mom,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv"sep="")#
	write.csv(current_population,write_name,col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
}
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-mom,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv"sep="")#
	write.csv(current_population,write_name,col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
}
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-mom,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv", sep="")#
	write.csv(current_population, write_name, col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-mom,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv", sep="")#
	write.csv(current_population, write_name, col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
}
t = 1
next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
next_gen_ID_tracker <- 1
for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-mom,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}
for (i in 1:nrow(current_population)){
mom <- current_population[i,]
Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)
mates <- current_population[-mom,]
n_offspring <- reproduce(mom, nstar, Rmax, k, mates)
dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)
dads_list_reformat <- convert_dads_list(dads_list)
for (n in 1:n_offspring){
dad <- dads_list_reformat[n]
offspring <- make_offspring(mom, dad, current_population, t, indiv_num)
next_generation[next_gen_ID_tracker,] <- offspring
next_gen_ID_tracker <- next_gen_ID_tracker + 1
}
for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-i,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-i,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, indiv_num)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv", sep="")#
	write.csv(current_population, write_name, col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-i,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, current_population, t, n)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv", sep="")#
	write.csv(current_population, write_name, col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
#
}
make_offspring <- function(mom, dad, generation, indiv_num){ # this whole function assumes that the first two columns of any indidividual have their generation number and their individual number. So locus 1 is in the third entry of the vector that defines every individual, and so on.#
	# give the baby it's generation number and individual number#
	baby_vec_length = meta_cols + total_genome_length#
	baby <- matrix(0,nrow = 1, ncol = baby_vec_length)#
	baby[,1] <- generation#
	baby[,2] <- indiv_num#
	baby[,3] <- disperse1D(mom[,3], zda(mom, disp_a_locus_1, disp_a_locus_last), zdb(mom, disp_b_locus_1, disp_b_locus_last))#
	# create the baby's genome#
	locus_vec <- seq(from = 3, to = total_genome_length+2, by = 2)#
	for (i in locus_vec){#
		if (i%%2 != 0){ # if this is an the first chromosome of a pair, inherit from mom at random#
			momallele = round(runif(1)) + i # choose either the allele at locus i_1 or at locus i_2#
			baby[,i] = mom[,momallele] #
		}	else { # if this is an odd chromosome, inherit from dad at random#
				dadallele = round(runif(1))+i	# choose either the allele at locus i_1 or at locus i_2 from dad's genome#
				baby[,i+1] = dad[,dadallele]	#
			}#
	}#
	# now mutate if needed#
	if (runif(1) < 1){#
		focal_locus <- sample(c(4:total_genome_length+3),1) # sample a random locus#
		mut_allele <- rnorm(1, baby[focal_locus], sigma_mut)#
		baby[focal_locus] <- mut_allele#
	}#
	return(baby)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
for (t in 1:t_max){#
	# (1) Reproduction#
	# (2) Parental Death#
	# (3) Dispersal (but this is density independent)#
	# (3) F1 Reproduction#
	# (1) & (2) - offspring dispersal is built into the make_offspring function. #
	next_generation <- make_popn_dataframe(t, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	next_gen_ID_tracker <- 1#
	for (i in 1:nrow(current_population)){#
		mom <- current_population[i,]#
		Rmax <- environment(mom$location, Rmax_good, Rmax_bad, t, env_length)#
		mates <- current_population[-i,]#
		n_offspring <- reproduce(mom, nstar, Rmax, k, mates)#
		dads_list <- matefinder1D(n_offspring, mom, mates, nbhd_width)#
		dads_list_reformat <- convert_dads_list(dads_list)#
		for (n in 1:n_offspring){#
			dad <- dads_list_reformat[n]#
			offspring <- make_offspring(mom, dad, t, n)#
			next_generation[next_gen_ID_tracker,] <- offspring#
			next_gen_ID_tracker <- next_gen_ID_tracker + 1#
		}#
	}#
	# write the parental generation to file before erasing them (annuals)#
	write_name <- paste("/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files/lascali_sim_dispevo_only_gen_",t,".csv", sep="")#
	write.csv(current_population, write_name, col_names = TRUE, row_names = TRUE)#
	current_population <- next_generation#
#
}
filepathspec = "/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files"
file = paste(filepathspec,"/parameters_from_sim.txt", sep = '')
file
# Dispersal Evolution Simulations#
# Author: Courtney Van Den Elzen#
# Rotation 3 Project: Melbourne and Flaxman Labs#
# February 2017 - June 2017#
#
# The goal of this project is to set up a simulation modelling framework which can be used to describe the population dynamics and spread of annual, wind-dispersed grassland plants#
#
# MAP OF THIS SCRIPT:#
#
# (1) Assumptions#
# (2) Constants#
# (3) Population Data Frame Creation#
# (4) Reproductive Functions#
# (5) Dispersal Functions#
# (6) The Environment#
# -------------------------------- (1) ASSUMPTIONS -------------------------------- #
#
 # (1) Discrete generations#
 # (2) Diploid organisms #
 # (3) Self-incompatible#
 # (4) Two traits controlling dispersal evolution, both have multiple loci controlling them. First controls average dispersal distance, second controls shape param of kernel #
 # (5) One trait controlling environmental evolution. Has multiple loci controlling it.#
 # (6) Multiple neutral loci used to observe neutral accumulation of genetic variation, as well as allele surfing#
 # (7) Mutations arise with probability 0.00001 in any individual. It is assumed that 2 or more mutations per individual never happens, since probability is max 0.00001^2. #
 # (8) Multiple fathers possible - probability of paternity based entirely on distance from mother (probably roughly true for passively dispersed pollen)#
 # (9) Every individual has chance at being both mother and father#
 # (10) Free recombination (every locus is on a different chromosome). Implemented as randomly drawing one allele from each parent at each locus#
 # (11) XXXXXXX - need to complete this section#
# -------------------------------- (2) CONSTANTS -------------------------------- #
#
# meta_cols: The number of metadata columns present. In the first iteration of this simulation, there are 3: (1) Generation (2) Individual ID (a unique (within generation) identifier of the individual) (3) Location#
# ploidy: The ploidy level of the genome. In general this will always be equal to 2 (diploid organisms)#
# disp_a_loci: The number of diploid loci that contribute to the dispersal parameter a#
# disp_b_loci: The number of diploid loci that contribute to the dispersal parameter b#
# env_loci: The number of diploid loci that contribute to the environmental (or fitness) parameter.#
# neut_loci: The number of diploid loci that are neutral in the genome and do not contribute to any phenotype #
# total_genome_length: The total number of loci in the genome, but one diploid locus contributes 2. i.e. t_g_l <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
# Rmax_good: The intrinsic growth rate in the "good" habitat/environment #
# Rmax_bad: The intrinsic growth rate in the "bad" habitat/environment#
# nstar: The interdensity an individual feels at which the expected number of #
# p_mut: The probability of acquiring a mutation. We assume that only one mutation max is acquired per individual because the porbability of more than one is sufficiently sml#
# sigma_mut: The standard deviation of the mutation kernel - mutations are drawn from a normal distribution with mean p_mut and sd sigma_mut#
# nbhd_width: The "width" or "size" or "standard deviation" of the neighbourhood. The neighbourhood weight is a normal distribution with mean of the maternal location & sd nbhd_width#
# env_length: The length of the "good" habitat location. This should be varied (i.e. the neighbourhood size to environment size varies) as this may have consequences for dipsersal evo#
# t_max: the max number of generations to run the simulation for#
# env_change_speed: The shift in the location of the good habitat every time step#
# init_loc_mean: Mean of the initial location distribution which initial population locations are drawn from #
# k: From Phillips 2015 - controls the drop in fitness as zw deviates from zero (optimal)#
# disp_a_allele: The initial allelic value for the disp_a trait#
# disp_b_allele: The initial allelic value for the disp_b trait#
# env_allele: The initial allelic value for the environmental trait#
#
# -------------------------------- (3) POPULATION DATA FRAME CREATION -------------------------------- #
#
# Structure of the data frame which holds all of the population information (number of metadata columns may change):#
   # Column 1: generation#
   # Column 2: individual ID (number from 1 to pop size in the current generation)#
   # Column 3: location#
   # Column 4-13: dispersal trait 1 (a = mean) loci (2 columns per locus because of diploidy)#
   # Column 14-23: dispersal trait 2 (b = shape) loci #
   # Column 24-33: environmental loci#
   # Column 34-43: neutral loci#
# Makes the original data frame with the right numbers of columns and the right column labels -- use this to create an empty data frame to store the data from each generation#
# t: the generation#
# nrows: the number of entries budgetted for the new generation (there is no condition for if the new gen exceeds this number -- should further modify)#
# all other input variables as above#
#
make_popn_dataframe <- function(t, nrows, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	#empty dataframe#
	current_population <- as.data.frame( matrix(data = 0, nrow = nrows, ncol = (meta_cols + total_genome_length)) ) # SMF comment: initially dims were 1 x 1#
	# SMF comment: if the data in this object are always going to be zeros, why not just keep it as a matrix? #
	# SMF comment: A matrix has fewer options and properties, so it may not work elsewhere, but just something to think about#
	# create the metadata columns#
	current_population[,1:meta_cols] <- c(0) # SMF comment: was growing dynamically in columns (and only had one row still)#
	# give them the right names#
	colnames(current_population) <- meta_col_names#
	# define some necessary objects - these are used to figure out which columns to create and what information they hold#
 	disp_a_locus_1 <- meta_cols+1#
	disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
	disp_b_locus_1 <- disp_a_locus_last + 1#
	disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
	env_locus_1 <- disp_b_locus_last + 1#
	env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
	neut_locus_1 <- env_locus_last + 1#
	neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
	# create all of the necessary new columns for the loci (after metadata columns)#
	for (i in seq(from=meta_cols, to=(total_genome_length+meta_cols), by=1)){#
		current_population[,i] <- 0#
	}#
#
	# # create all of the necessary new columns for the loci (after metadata columns) # SMF comment: no longer needed#
	# for (i in seq(from=meta_cols, to=(total_genome_length+meta_cols), by=1)){ # SMF comment: grows columns again dynamically; still 1 row#
	# 	current_population[,i] <- 0#
	# }#
#
	# Names the columns properly - accounts for changes in number of loci or ploidy of loci controlling traits, as well as differences in number of metadata columns. #
	for (i in (meta_cols+1):ncol(current_population)){#
		# if the number of metadata columns is even (this matters for deciding which columns correspond to diploid loci pairs, if meta_cols is even then 1st copy is also an even col)#
		if (meta_cols%%2 != 0){#
			if (i%%2 == 0) {#
				if (4 <= i && i <= disp_a_locus_last){#
					j = i-meta_cols#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispa_locus',k,'1',sep = "_")#
				} else if (disp_b_locus_1 <= i && i <= disp_b_locus_last){#
					j = i-disp_a_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispb_locus',k,'1',sep = "_")#
				} else if (env_locus_1 <= i && i <= env_locus_last) {#
					j = i-disp_b_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('env_locus',k,'1',sep = "_")#
				} else if (neut_locus_1 <= i && i <= neut_locus_last) {#
					j = i-env_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('neut_locus',k,'1',sep = "_")#
				}#
			} else { # SMF comment: changed to else#
				if (4 <= i && i <= disp_a_locus_last){#
					j = i-meta_cols#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispa_locus',k,'2',sep = "_")#
				} else if (disp_b_locus_1 <= i && i <= disp_b_locus_last){#
					j = i-disp_a_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispb_locus',k,'2',sep = "_")#
				} else if (env_locus_1 <= i && i <= env_locus_last) {#
					j = i-disp_b_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('env_locus',k,'2',sep = "_")#
				} else if (neut_locus_1 <= i && i <= neut_locus_last) {#
					j = i-env_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('neut_locus',k,'2',sep = "_")#
				}#
			}#
		} else {#
			if (i%%2 != 0) {#
				if (4 <= i && i <= disp_a_locus_last){#
					j = i-meta_cols#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispa_locus',k,'1',sep = "_")#
				} else if (disp_b_locus_1 <= i && i <= disp_b_locus_last){#
					j = i-disp_a_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispb_locus',k,'1',sep = "_")#
				} else if (env_locus_1 <= i && i <= env_locus_last) {#
					j = i-disp_b_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('env_locus',k,'1',sep = "_")#
				} else if (neut_locus_1 <= i && i <= neut_locus_last) {#
					j = i-env_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('neut_locus',k,'1',sep = "_")#
				}#
			} else {#
				if (4 <= i && i <= disp_a_locus_last){#
					j = i-meta_cols#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispa_locus',k,'2',sep = "_")#
				} else if (disp_b_locus_1 <= i && i <= disp_b_locus_last){#
					j = i-disp_a_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('dispb_locus',k,'2',sep = "_")#
				} else if (env_locus_1 <= i && i <= env_locus_last) {#
					j = i-disp_b_locus_last#
					k = round((j/2)+0.0000001)#
					colnames(current_population)[i] <- paste('env_locus',k,'2',sep = "_")#
				} else if (neut_locus_1 <= i && i <= neut_locus_last) {#
					j = i-env_locus_last#
					k = round((j/2)+0.0000001)#
				colnames(current_population)[i] <- paste('neut_locus',k,'2',sep = "_")#
				}	#
			}#
		}#
	}#
	# add all rows specified above. All entries are zero until changed.#
	# current_population[c(1:nrows),] <- 0 # SMF comment: no longer necessary; dynamically grew rows#
	return(current_population)#
}#
# This uses the make_popn_dataframe function to create a data frame and then fill it with N individuals#
# Initial location of individuals is determined by random draws from norm(init_location, nbhd_width). #
# N: number of inidividuals#
# all other input variables as above#
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ncol = ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[1:N,] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	for (i in 1:N){#
		init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	}#
	return(curr_pop)#
}
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ncol = ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[1:N,] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
# This script contains parameter assignments and the simulation loop#
#
# File Path - where do you want simualtion files to go?#
filepathspec = "/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files"#
#
#Packages#
library(statmod)#
#
# Parameters - explained in LastheniaDispersalSimulationFunctions script#
meta_cols <- 3 #
meta_col_names <- c('generation','individual_ID','location')  #
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 #
Rmax_bad <- 0#
nstar <- 100#
p_mut <- 0.00001 #
sigma_mut <- 0.001 #
nbhd_width <- 1 #
env_length <- 10 #
t_max <- 100#
env_change_speed <- 0.1#
init_loc_mean <- 0#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 0#
#
# Derived Params#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1
parameters <- paste("meta_cols: ", meta_cols, ", ploidy: ", ploidy, ", disp_a_loci: ", disp_a_loci, ", disp_b_loci: ", disp_b_loci, ", env_loci: ", env_loci, ", neut_loci: ", neut_loci, ", Rmax_good: ", Rmax_good, ", Rmax_bad: ", Rmax_bad, ", nstar: ", nstar, ", p_mut: ", p_mut, ", sigma_mut: ", sigma_mut, ", nbhd_width: ", nbhd_width, ", env_length: ", env_length, ", t_max: ", t_max, ", init_loc_mean: ", init_loc_mean, ", k: ", k, ", disp_a_allele: ", disp_a_allele, ", disp_b_allele: ", disp_b_allele, ", env_allele: ", env_allele)#
write(parameters, file = paste(filepathspec,"/parameters_from_sim.txt", sep = ''))
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ncol = ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[1:N,] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ncol = ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
	print(curr_pop)#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop_gen0 <- make_popn_dataframe(t, nrows, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop_gen0 <- make_popn_dataframe(0, nstar, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop_gen0
make_popn_dataframe(t, 0, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, 0, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
# This script contains parameter assignments and the simulation loop#
#
# File Path - where do you want simualtion files to go?#
filepathspec = "/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files"#
#
#Packages#
library(statmod)#
#
# Parameters - explained in LastheniaDispersalSimulationFunctions script#
meta_cols <- 3 #
meta_col_names <- c('generation','individual_ID','location')  #
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 #
Rmax_bad <- 0#
nstar <- 100#
p_mut <- 0.00001 #
sigma_mut <- 0.001 #
nbhd_width <- 1 #
env_length <- 10 #
t_max <- 100#
env_change_speed <- 0.1#
init_loc_mean <- 0#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 0#
#
# Derived Params#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, c(1:N), 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
# This script contains parameter assignments and the simulation loop#
#
# File Path - where do you want simualtion files to go?#
filepathspec = "/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files"#
#
#Packages#
library(statmod)#
#
# Parameters - explained in LastheniaDispersalSimulationFunctions script#
meta_cols <- 3 #
meta_col_names <- c('generation','individual_ID','location')  #
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 #
Rmax_bad <- 0#
nstar <- 100#
p_mut <- 0.00001 #
sigma_mut <- 0.001 #
nbhd_width <- 1 #
env_length <- 10 #
t_max <- 100#
env_change_speed <- 0.1#
init_loc_mean <- 0#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 0#
#
# Derived Params#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	print(disp_a_genome)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
# This script contains parameter assignments and the simulation loop#
#
# File Path - where do you want simualtion files to go?#
filepathspec = "/Users/Courtney/Documents/Rotation 3 - Melbourne & Flaxman Labs/Simulation Practice Files"#
#
#Packages#
library(statmod)#
#
# Parameters - explained in LastheniaDispersalSimulationFunctions script#
meta_cols <- 3 #
meta_col_names <- c('generation','individual_ID','location')  #
ploidy <- 2#
disp_a_loci <- 5#
disp_b_loci <- 5#
env_loci <- 5#
neut_loci <- 5#
total_genome_length <- ploidy*(disp_a_loci+disp_b_loci+env_loci+neut_loci)#
Rmax_good <- 50 #
Rmax_bad <- 0#
nstar <- 100#
p_mut <- 0.00001 #
sigma_mut <- 0.001 #
nbhd_width <- 1 #
env_length <- 10 #
t_max <- 100#
env_change_speed <- 0.1#
init_loc_mean <- 0#
k <- 1#
disp_a_allele <- 1 #
disp_b_allele <- 2#
env_allele <- 0#
#
# Derived Params#
disp_a_locus_1 <- meta_cols+1#
disp_a_locus_last <- disp_a_locus_1 + disp_a_loci*ploidy - 1#
disp_b_locus_1 <- disp_a_locus_last + 1#
disp_b_locus_last <- disp_b_locus_1 + disp_b_loci*ploidy - 1#
env_locus_1 <- disp_b_locus_last + 1#
env_locus_last <- env_locus_1 + env_loci*ploidy - 1#
neut_locus_1 <- env_locus_last + 1#
neut_locus_last <- neut_locus_1 + neut_loci*ploidy - 1#
#
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
current_population
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	print(disp_a_genome)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	#curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, 0, 0, 0)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	print(disp_a_genome)#
	disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	#curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, 0, 0, 0)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	# disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	# disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	# env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	# neut_genome <- rep(0, ploidy*neut_loci)#
	disp_a_genome <- rep(0, ploidy*disp_a_loci)#
	disp_b_genome <- rep(0, ploidy*disp_b_loci)#
	env_genome <- rep(0, ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	#curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	# disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	# disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	# env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	# neut_genome <- rep(0, ploidy*neut_loci)#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(0, ploidy*disp_b_loci)#
	env_genome <- rep(0, ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	#curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	#curr_pop[,2] <- rnorm(nrow(curr_pop), mean = init_location, sd = nbhd_width)#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
curr_pop#
disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
disp_a_genome#
disp_b_genome <- rep(0, ploidy*disp_b_loci)#
disp_b_genome#
env_genome <- rep(0, ploidy*env_loci)#
env_genome#
neut_genome <- rep(0, ploidy*neut_loci)#
neut_genome
curr_pop[c(1:N),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop[c(1:10),] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop[1,] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop[1,] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
length(c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome))
curr_pop[1:10,1:length(c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome))] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop[1:2,] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop[1:2,] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
disp_a_genome <- rep("a", ploidy*disp_a_loci)#
disp_a_genome#
disp_b_genome <- rep("b", ploidy*disp_b_loci)#
disp_b_genome#
env_genome <- rep("e", ploidy*env_loci)#
env_genome#
neut_genome <- rep("n", ploidy*neut_loci)#
neut_genome
curr_pop[1:2,] <- c(0, 0, 0, disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop[1,]
curr_pop[1:2,] <- c("gen", "ID", "loc", disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop[1:2,] <- c("gen", "ID", "loc", disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop[1,] <- c("gen", "ID", "loc", disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop[c(1,2),] <- c("gen", "ID", "loc", disp_a_genome, disp_b_genome, env_genome, neut_genome)
curr_pop
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop
curr_pop[c(1:N),] <- 0
curr_pop[c(1:10),] <- 0
curr_pop
curr_pop[,1] <- "gen"
curr_pop
curr_pop[,2] <- "ID"
curr_pop
curr_pop[,c(1,2)] <- c("gen2","ID2")
curr_pop
curr_pop[,1:2] <- c("gen2","ID2")
curr_pop
curr_pop[1:2,] <- c("gen2","ID2")
curr_pop
curr_pop[1:2] <- c("gen2","ID2")
curr_pop[c(1:10),] <- 0
curr_pop[1:2] <- c("gen2","ID2")
curr_pop
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	# disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	# disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	# env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	# neut_genome <- rep(0, ploidy*neut_loci)#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(0, ploidy*disp_b_loci)#
	env_genome <- rep(0, ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[,1] <- t#
	curr_pop[,2] <- c(1:N)#
	curr_pop[,3] <- rnorm(N, mean = init_location, sd = nbhd_width)#
	curr_pop[,4:13] <- disp_a_genome#
	curr_pop[,14:23] <- disp_b_genome#
	curr_pop[,24:33] <- env_genome#
	curr_pop[,34:43] <- neut_genome#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
curr_pop[,1] <- "gen"
curr_pop[,2] <- "ID"
curr_pop[,3] <- rnorm(N, mean = init_location, sd = nbhd_width)
curr_pop[,3] <- rnorm(10, mean = init_location, sd = nbhd_width)
curr_pop[,3] <- rnorm(10, mean = 0, sd = 1)
rnorm(10, mean = 0, sd = 1)
curr_pop[,3]
curr_pop[c(1:10),] <- 0
curr_pop[,3]
curr_pop[c(1:10),] <- 0
curr_pop[,1] <- "gen"
curr_pop[,2] <- "ID"
curr_pop[,3] <- rnorm(10, mean = 0, sd = 1)
curr_pop
curr_pop[1:N,] <- 0
make_pop <- function(t, N, init_location, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci){#
	# make an initial empty data frame (this has one row by default, which is overwritten in the for loop below)#
	curr_pop <- make_popn_dataframe(t, 1, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)#
#
	# fills in the columns with the initial values of the three traits (disp_a, disp_b, and env). Could make random draws from a distribution to seed init pop with genetic variation. #
	# SMF comment: eliminated unnecessary coercion steps#
	# disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	# disp_b_genome <- rep(disp_b_allele/(ploidy*disp_b_loci), ploidy*disp_b_loci)#
	# env_genome <- rep(env_allele/(ploidy*env_loci), ploidy*env_loci)#
	# neut_genome <- rep(0, ploidy*neut_loci)#
	disp_a_genome <- rep(disp_a_allele/(ploidy*disp_a_loci), ploidy*disp_a_loci)#
	disp_b_genome <- rep(0, ploidy*disp_b_loci)#
	env_genome <- rep(0, ploidy*env_loci)#
	neut_genome <- rep(0, ploidy*neut_loci)#
	curr_pop[1:N,] <- 0#
	# choose random initial location for every individual in the population, and then create the inidividual. The first zero denotes ???? COME BACK TO THIS#
	curr_pop[,1] <- t#
	curr_pop[,2] <- c(1:N)#
	curr_pop[,3] <- rnorm(N, mean = init_location, sd = nbhd_width)#
	curr_pop[,4:13] <- disp_a_genome#
	curr_pop[,14:23] <- disp_b_genome#
	curr_pop[,24:33] <- env_genome#
	curr_pop[,34:43] <- neut_genome#
	# for (i in 1:N){#
		# init_loc_rand <- rnorm(1, mean = init_location, sd = nbhd_width)#
		# curr_pop[i,] <- c(0, i, init_loc_rand, disp_a_genome, disp_b_genome, env_genome, neut_genome)#
	# }#
	return(curr_pop)#
}
current_population <- make_pop(0, nstar, init_loc_mean, nbhd_width, disp_a_allele, disp_b_allele, env_allele, meta_cols, meta_col_names, ploidy, disp_a_loci, disp_b_loci, env_loci, neut_loci)
current_population
